# coding: UTF-8

'''
Create an audio file as it is generated by the RP2A03 DPCM function
'''

import wave
import sys
import struct
import numpy as np
import math

def writeWav(inData, inSampFreq, inFileName):
    '''
    Save wav file.
    It assumes input data is mono and 16-bit sample
    @param inData Input audio data
    @param inSampFreq Sampling frequency [Hz]
    @param inFileName Output file name
    '''

    data = struct.pack("h" * len(inData), *inData)
    wf = wave.open(inFileName, "w")
    wf.setnchannels(1)
    wf.setsampwidth(2)
    wf.setframerate(inSampFreq)
    wf.writeframes(data)
    wf.close()


def readWav(inFileName):
    '''
    Read the audio file.
    It must be an uncompressed, 16-bit sample WAV file.
    Number of channels is 1 or 2.
    If the number of channels is 2, it reads only the left channel.
    @param inFileName Audio file name (.wav)
    @return [audio data, sampling frequency [Hz]]
    '''

    # Open file
    wr = wave.open(inFileName, "rb")

    # Check the validity of the file
    # 1 sample is consisting of 16 bits
    if wr.getsampwidth() != 2:
        print(" error : size per one sample must be 2.")
        wr.close()
        usage()
        quit()
    # Uncompressed
    if wr.getcomptype() != "NONE":
        print(" error : input file must be uncompresed format.")
        wr.close()
        usage()
        quit()
    # Number of channels is either 1 or 2
    channels = wr.getnchannels()
    if channels != 1  and channels != 2 :
        print(" error : channel number must be 1 or 2.")
        wr.close()
        usage()
        quit()

    # Read
    sampFreq = wr.getframerate()
    data = wr.readframes(wr.getnframes())
    numData = np.frombuffer(data, dtype=np.int16)
    wr.close()

    # Conver read data to int list
    i=0
    out = []
    while i<len(numData):
        #out.append(int(np.ndarray.item(np.float64(numData[i]))))
        out.append(int(np.float64(numData[i])))
        # If the number of channels is 2, get only the Left channel
        i += channels

    return [out, sampFreq]


def convDpcm(inData, inSampFreq, inRegId):

    '''
    Create a sound generated from the DPCM channel.
    Reference URL: http://dic.nicovideo.jp/a/fc音源
    Procedure
     1. Create a sample value after compression
      1st sample:
       - Compress the original sample value (16-bit) to 7-bit
      2nd sample or later:
       - Compress the sample value (16 bits) to 7 bits.
       - Compare it with the previous compressed value
         - If the new compressed value is larger than the previous one, add one to the previous value.
         - If the new compressed value is the same as or smaller than the previous one, subtract one from the previous value.
      2. Convert to audio
       Set the last 1 bit of the value to 0.
        (Delta initial volume is 7 bits long, but during playback, the volume is controlled in 64 steps ignoring the last 1 bit.)
       Then, shift left by 9 bits (=16-9) to restore the number of quantization bits to 16.

    @param inData Input audio data
    @param inSampFreq Sampling frequency of input audio [Hz]
    @param inRegId Sampling frequency after DPCM conversion.
    '''

    # Determine the sampling frequency of DPCM output
    # Get the frequency corresponding to the specified argument (0-15) from the table
    # Sampling frequency [Hz] = 1789772.5 / value gotten from the table
    if inRegId < 0 or inRegId > 15:
        print(" error : number for determining sampling frequency must be from 0 to 15.")
        usage()
        quit()
    dpcmFreqTable = [428,380,340,320,286,254,226,214,190,160,142,128,106,85,72,54]
    dpcmFreq = 1789772.5 / dpcmFreqTable[inRegId]
    print(" DPCM-converting sampling frequency[Hz]:", dpcmFreq)

    # Duration of sound
    totalTime = float(len(inData)) / inSampFreq

    # Initial setting
    # Time of sample
    t = 0.0
    # Time of the previous sample
    prev = 0.0
    # Output
    out = []

    while t < totalTime:

        # Get a sample
        sample = inData[int(math.floor(t * inSampFreq))]

        if t <= 0.0:
            # When it's first sample,
            # Compress sample into 7 bits
            # Python's shift operation is a "mathematical shift", so moving 9 bits (=16-7) to the right works
            val = sample >> 9
        else:
            # When it's second sample or later
            # Compress sample
            tmpVal = sample >> 9
            # If the compressed sample is larger than the previous sample, add one to the previous sample.
            # Otherwise, subtract one from the previous sample.
            if tmpVal > prev:
                val = prev+1
            else:
                val = prev-1

        # Round the compressed sample in the range from -64 to 63 (7-bit signed integer)
        if val > 63:
            val = 63
        elif val < -64:
            val = -64

        # Register compressed sample
        out.append(val)
        # Store the sample as "previous sample"
        prev = val

        # Update time
        t += 1.0 / dpcmFreq

    # Re-convert compressed samples into 16-bit uncompressed samples
    # The compressed sample is in 7 bits, and the last 1 bit will be ignored in the volume control, so after deleting the last 1 bit, convert to a 16-bit signal.
    for i in range(len(out)):
        out[i] = (out[i] >> 1) << 10

    # Return output
    return [out, dpcmFreq]

# usage
def usage():

    print("usage: python dpcm.py (input file) (output file) [options]")
    print(" This script converts input speech so as to be played from NES DPCM channel.")
    print("  (input file) : input wav file name.")
    print("  (output file) : output wav file name.")
    print("  [options]")
    print("   -ds (number) : specify DPCM sampling frequency.")
    print("     The specified number must be in the range from 0 to 15 [defalut=15].")
    print("     Each number indicates a stored value to a register that determines")
    print("     DPCM sampling frequency.")
    print("     The relationship between the specified numbers and the sampling")
    print("     frequencies are as followings:")
    print("       (number) (frequency[Hz])")
    print("             0            4182")
    print("             1            4710")
    print("             2            5264")
    print("             3            5593")
    print("             4            6258")
    print("             5            7046")
    print("             6            7919")
    print("             7            8363")
    print("             8            9420")
    print("             9           11186")
    print("            10           12604")
    print("            11           13983")
    print("            12           16885")
    print("            13           21056")
    print("            14           24858")
    print("            15           33144")


if __name__ == "__main__" :

    # Get arguments
    if len(sys.argv) < 3:
        print(" error : less args.")
        usage()
        quit()

    # Get input file
    inFileName = sys.argv[1]
    # Get output file
    outFileName = sys.argv[2]

    # Get DPCM output's sampling generated
    # (Default)
    dpcmFlag = 15
    i=3
    while i<len(sys.argv):
        if sys.argv[i] == '-ds':
            i+=1
            if i>=len(sys.argv):
                print(" error : invalid args.")
                usage()
                quit()
            if not sys.argv[i].isdigit():
                print(" error : invalid args.")
                usage()
                quit()
            dpcmFlag = int(sys.argv[i])
        else:
            print(" error : invalid args.")
            usage()
            quit()
        i+=1

    # Read input audio file
    [data, sampFreq] = readWav(inFileName)

    print(" input file:", inFileName)
    print(" output file:", outFileName)
    print(" input sampling frequency [Hz]:", sampFreq)
    print(" speech length [s]:", float(len(data)) / sampFreq)

    # Convert with DPCM
    [out, dpcmFreq] = convDpcm(data, sampFreq, dpcmFlag)

    # Detemine sampling frequency of output file
    # For WAV format, the sampling frequency must be an integer, so the frequency is rounded.
    outSampFreq = round(dpcmFreq)
    print(" output sampling frequency[Hz]:", outSampFreq)

    # Write output file
    writeWav(out, outSampFreq, outFileName)
